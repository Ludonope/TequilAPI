<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>TequilAPI ðŸŒ®</title>

        <link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Merriweather:400,900,700,300|Open+Sans:400,800,700|Titillium+Web:600,400' type='text/css'>
        <link rel="stylesheet" href="http://ludonope.github.io/TequilAPI/css/bootstrap.min.css">
        <link rel="stylesheet" href="http://ludonope.github.io/TequilAPI/css/font-awesome.min.css">
        <link rel="stylesheet" href="http://ludonope.github.io/TequilAPI/css/github.css">
        <link rel="stylesheet" href="http://ludonope.github.io/TequilAPI/css/main.css">
    </head>
    <body>

        <header class="site-header">
            <div class="site-branding">
                <h1 class="site-name">
                    <a href="http://ludonope.github.io/TequilAPI" >TequilAPI ðŸŒ®</a>&nbsp;&nbsp;<i class="fa"></i>
                </h1>
                <h2 class="site-description">A good API for a good project</h2>
            </div>

            <div class="button-line">
                <a href="https://github.com/Ludonope/TequilAPI" target="_blank" class="btn btn-default">View on GitHub</a>
                <a href="https://github.com/Ludonope/TequilAPI/zipball/master" class="btn btn-default hidden-xs">Download .zip</a>
                <a href="https://github.com/Ludonope/TequilAPI/tarball/master" class="btn btn-default hidden-xs">Download .tar.gz</a>
            </div>

                            <a href="https://github.com/Ludonope/TequilAPI">
                    <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png">
                </a>
            
            <div class="text-left visible-xs-block" style="margin-left: 15px;">
                <a href="#sidebar" data-toggle="collapse"><i class="fa fa-3x fa-bars" aria-hidden="true"></i></a>
            </div>
        </header>

        <main class="container-fluid">
            <div class="row">

                                    <nav id="sidebar" class="col-sm-3 col-lg-2 collapse in" role="navigation">
                                                    <p class="text-muted">
                                Getting started
                            </p>

                            <ul class="nav nav-pills nav-stacked">
                                                                    <li class="">
                                        <a href="http://ludonope.github.io/TequilAPI/index.html#tequilapi">
                                            TequilAPI
                                        </a>
                                    </li>
                                                                    <li class="">
                                        <a href="http://ludonope.github.io/TequilAPI/index.html#how-does-the-server-works-">
                                            How does the server works ?
                                        </a>
                                    </li>
                                                                    <li class="">
                                        <a href="http://ludonope.github.io/TequilAPI/index.html#the-core">
                                            The Core
                                        </a>
                                    </li>
                                                                    <li class="">
                                        <a href="http://ludonope.github.io/TequilAPI/index.html#the-http-request-and-response">
                                            The http Request and Response
                                        </a>
                                    </li>
                                                                    <li class="">
                                        <a href="http://ludonope.github.io/TequilAPI/index.html#the-modules">
                                            The modules
                                        </a>
                                    </li>
                                                                    <li class="">
                                        <a href="http://ludonope.github.io/TequilAPI/index.html#the-connection-module">
                                            The Connection module
                                        </a>
                                    </li>
                                                                    <li class="">
                                        <a href="http://ludonope.github.io/TequilAPI/index.html#the-configuration-loader-module">
                                            The Configuration Loader module
                                        </a>
                                    </li>
                                                                    <li class="">
                                        <a href="http://ludonope.github.io/TequilAPI/index.html#the-logger-module">
                                            The Logger module
                                        </a>
                                    </li>
                                                                    <li class="">
                                        <a href="http://ludonope.github.io/TequilAPI/index.html#the-handler-module">
                                            The Handler module
                                        </a>
                                    </li>
                                                                    <li class="">
                                        <a href="http://ludonope.github.io/TequilAPI/index.html#the-filter-module">
                                            The Filter module
                                        </a>
                                    </li>
                                                                    <li class="">
                                        <a href="http://ludonope.github.io/TequilAPI/index.html#the-project-uml">
                                            The Project UML
                                        </a>
                                    </li>
                                                            </ul>
                        
                    </nav>

                
                <section class="col-sm-9 col-lg-10 content">
                    <h1 id="getting-started">Getting started</h1>
<h2 id="how-does-the-server-works-">How does the server works ?</h2>
<p>The server works with a core and different types of module.</p>
<ul>
<li>The Connection module manages the network I/O and communicate with the Core through input and output queues.</li>
<li>The Config Loader module, well, loads the configurations.</li>
<li>Logger modules does log.</li>
<li>Handlers take an http request, and if it can handle it, fill an http response.</li>
</ul>
<p>There is also something called Filter. Thoses are functions that are called at specific stages of the request processing to modify (if needed) the data.</p>
<p>The Core is here to store and manage every modules.</p>
<p><img src="https://github.com/Ludonope/TequilAPI/raw/master/how_does_it_works.png" alt="Picture describing how it works" /></p>
<h2 id="the-core">The Core</h2>
<p>It can load or unload a specific module.</p>
<pre><code class="language-cpp">virtual IModule *load(std::string const &amp;path);
virtual void unload(IModule *module);</code></pre>
<p>It can set or unset one of the main modules (Config Loader and Connection).</p>
<pre><code class="language-cpp">virtual void setConfigLoader(IConfigLoader *module);
virtual void setConnection(IConnection *module);
virtual void unsetConfigLoader(IConfigLoader *module);
virtual void unsetConnection(IConnection *module);</code></pre>
<hr />
<p>Here is the <code>SlotRegister</code>, it allows you to add or remove elements in a &quot;list&quot;, with positionning priority.</p>
<pre><code class="language-cpp">namespace teq
{
  enum class Priority
  {
    VeryLow = 0,
    Low = 1,
    Normal = 2,
    High = 3,
    VeryHigh = 4
  };
}</code></pre>
<pre><code class="language-cpp">namespace teq
{
  template &lt;typename T&gt;
  class SlotRegister
  {
  public:
    // ...
    T &amp;add(IModule const *parent, T const &amp;value, Priority priority = Priority::Normal);
    void remove(T const &amp;value);
    void clear(IModule const *parent);
    // ...
  };
}</code></pre>
<p>Note that the <code>SlotRegister</code> does not allow to access the stored elements.
To access thoses, we use a <code>SlotList</code> (which is a <code>SlotRegister</code>). This one allow direct access to the storage.</p>
<pre><code class="language-cpp">namespace teq
{
  template &lt;typename T&gt;
  class SlotList final : public SlotRegister&lt;T&gt;
  {
    // ...
    size_type size() const noexcept;
    bool empty() const noexcept;
    T const &amp;operator[](size_type index) const;
    T &amp;operator[](size_type index);
    iterator begin() noexcept;
    iterator end() noexcept;
    const_iterator begin() const noexcept;
    const_iterator end() const noexcept;
  };
}</code></pre>
<blockquote>
<p>The <code>begin()</code> and <code>end()</code> method will allow you to use this container in range-based for loops.</p>
</blockquote>
<p>The <code>Filter.hpp</code> file also define aliases on those types for uniform usage.</p>
<pre><code class="language-cpp">namespace teq
{
  namespace filter
  {
    enum class Type
    {
      InputData,
      Request,
      Response,
      OutputData
    };

    template &lt;Type T&gt;
    using Register = SlotRegister&lt;...&gt;;

    template &lt;Type T&gt;
    using List = SlotList&lt;...&gt;;
  }
}</code></pre>
<hr />
<p>Let's move back on the <code>ACore</code>.
So here are the loggers, handlers and filters getters.</p>
<pre><code class="language-cpp">virtual SlotRegister&lt;ILogger *&gt; &amp;loggers();
virtual SlotRegister&lt;IHandler *&gt; &amp;handlers();

template &lt;filter::Type T&gt;
filter::Register&lt;T&gt; &amp;get();</code></pre>
<p>You can add a specific filter this way</p>
<pre><code class="language-cpp">core.get&lt;filter::Type::Request&gt;().add(...);</code></pre>
<p>Finally, it has a <code>log</code> method which will pass the parameters to every registered logger.</p>
<pre><code class="language-cpp">virtual void log(LogType type, std::string const &amp;message);</code></pre>
<hr />
<blockquote>
<p>All of these methods are already implemented in the ACore, but you are free to override them as you want.</p>
</blockquote>
<hr />
<p>The <code>ACore</code> store all of theses modules.</p>
<pre><code class="language-cpp">// List of every loaded modules
std::vector&lt;std::pair&lt;std::unique_ptr&lt;GenModule&gt;, std::unique_ptr&lt;IModule&gt;&gt;&gt; m_modules;

// Main modules
IConfigLoader *m_configLoader;
IConnection *m_connection;

// Filter lists
filter::List&lt;filter::Type::InputData&gt; m_inputFilters;
filter::List&lt;filter::Type::Request&gt; m_requestFilters;
filter::List&lt;filter::Type::Response&gt; m_responseFilters;
filter::List&lt;filter::Type::OutputData&gt; m_outputFilters;

SlotList&lt;IHandler *&gt; m_handlers;
SlotList&lt;ILogger *&gt; m_loggers;

nlohmann::json m_config;</code></pre>
<p>The <code>GenModule</code> stored with each <code>IModule</code> represents the dynamically loaded library, and need to be
stored as long as the corresponding module exists.</p>
<p>The <code>nlohmann::json m_config</code> is the global config object,
it will store every module's config.</p>
<h2 id="the-http-request-and-response">The http Request and Response</h2>
<h2 id="ibase">IBase</h2>
<p>Both of these elements have a lot in common. This is why there is an <code>http::IBase</code> which provide them some methods.</p>
<p>Firstly, you can get and set the version.</p>
<pre><code class="language-cpp">virtual std::pair&lt;std::int32_t, std::int32_t&gt; version() const = 0;
virtual void setVersion(std::int32_t major = 1, std::int32_t minor = 1) = 0;</code></pre>
<p>This would allow this usage</p>
<pre><code class="language-cpp">req.setVersion(1, 1); // Setting the http version to 1.1

auto [major, minor] = req.version();

std::cout &lt;&lt; "Request version is &lt;&lt; major &lt;&lt; '.' &lt;&lt; minor &lt;&lt; std::endl;</code></pre>
<p>Same thing for the body</p>
<pre><code class="language-cpp">virtual std::string const &amp;body() const = 0;
virtual void setBody(std::string const &amp;body) = 0;</code></pre>
<p>Then you can access and manipulate the different parameters with those methods.</p>
<pre><code class="language-cpp">virtual bool hasParam(std::string const &amp;param) const = 0;
virtual std::string &amp;operator[](std::string const &amp;param) = 0;
virtual std::string const &amp;at(std::string const &amp;param) const = 0;
virtual std::string &amp;at(std::string const &amp;param) = 0;
virtual void clearParams() = 0;
virtual size_type paramCount() const noexcept = 0;

virtual iterator begin() noexcept = 0;
virtual iterator end() noexcept = 0;
virtual const_iterator begin() const noexcept = 0;
virtual const_iterator end() const noexcept = 0;</code></pre>
<blockquote>
<p>Again, you can note the <code>begin()</code> and <code>end()</code> methods for range-based for loop.</p>
</blockquote>
<p>Finally, both Request and Response might need to be displayed as a string.</p>
<pre><code class="language-cpp">virtual std::string toString() = 0;</code></pre>
<hr />
<h2 id="uri">Uri</h2>
<p>The <code>http::Uri</code> object will be used by the <code>IRequest</code> interface.
It can store a uri of this format.</p>
<pre><code class="language-http">https://www.ludonope.com/path/to/something.html?p=oui&amp;p2=non&amp;p3=ah</code></pre>
<p>You can access the path with those methods</p>
<pre><code class="language-cpp">std::string const &amp;path() const;
void setPath(std::string const &amp;path);</code></pre>
<p>You can check if it has a certain parameter</p>
<pre><code class="language-cpp">bool hasParam(std::string const &amp;param) const;</code></pre>
<p>This method allow you to get the uri as a string</p>
<pre><code class="language-cpp">std::string toString() const;</code></pre>
<p>Also, the global <code>operator&lt;&lt;</code> has been overloaded to allow using <code>http::Uri</code> directly with an <code>std::ostream</code>.</p>
<pre><code class="language-cpp">std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, teq::http::Uri const &amp;uri);</code></pre>
<p>Finally, to make the Uri parameters convenient, we made it inherit an <code>std::map</code>.</p>
<pre><code class="language-cpp">namespace teq
{
  namespace http
  {
    class Uri final : public std::map&lt;std::string, std::vector&lt;std::string&gt;&gt;
    {
      // ...
    };
  }
}</code></pre>
<p>This way, you can use it like a regular <code>std::map</code>, with all the good methods which come with it !</p>
<pre><code class="language-cpp">auto val = uri["search"][0];</code></pre>
<p>Notice that it's a <code>std::map</code> of <code>std::string</code> and a <code>vector&lt;std::string&gt;</code>. This is because you can have a parameter more than once. For example, this is a valid uri.</p>
<pre><code class="language-http">https://www.ludonope.com/search.php?query=hello&amp;query=world</code></pre>
<hr />
<h2 id="irequest">IRequest</h2>
<p>The request is quite simple. In addition of the IBase methods, it simply is composed of a method and a Uri.</p>
<pre><code class="language-cpp">virtual Method method() const = 0;
virtual void setMethod(Method method) = 0;
virtual Uri const &amp;uri() const = 0;
virtual void setUri(Uri const &amp;uri) = 0;</code></pre>
<p>The http methods are stored in an enum.</p>
<pre><code class="language-cpp">namespace teq
{
  namespace http
  {
    enum class Method
    {
      GET,
      HEAD,
      POST,
      PUT,
      DELETE,
      CONNECT,
      OPTIONS,
      TRACE
    };
  }
}</code></pre>
<hr />
<h2 id="iresponse">IResponse</h2>
<p>Similarly, the response is simply made of a status code and a reason (the corresponding message).</p>
<pre><code class="language-cpp">virtual StatusCode status() const = 0;
virtual void setStatus(StatusCode status) = 0;
virtual std::string const &amp;reason() const = 0;
virtual void setReason(std::string const &amp;reason) = 0;</code></pre>
<p>The different status code are stored in a enum. You can add custom ones in your implementation.</p>
<pre><code class="language-cpp">namespace teq
{
  namespace http
  {
    struct StatusCode
    {
      enum
      {
        // Informational
        Continue = 100,
        SwitchingProtocol = 101,

        // Success
        OK = 200,
        Created = 201,
        Accepted = 202,
        NonAuthoritativeInformation = 203,
        NoContent = 204,
        ResetContent = 205,
        PartialContent = 206,

        // Redirection
        MultipleChoices = 300,
        MovedPermanently = 301,
        Found = 302,
        SeeOther = 303,
        NotModified = 304,
        UseProxy = 305,
        TemporaryRedirect = 307,

        // Client Error
        BadRequest = 400,
        Unauthorized = 401,
        PaymentRequired = 402,
        Forbidden = 403,
        NotFound = 404,
        MethodNotAllowed = 405,
        NotAcceptable = 406,
        ProxyAuthentificationRequired = 407,
        RequestTimeOut = 408,
        Conflict = 409,
        Gone = 410,
        LengthRequired = 411,
        PreconditionFailed = 412,
        RequestEntityTooLarge = 413,
        RequestURITooLarge = 414,
        UnsupportedMediaType = 415,
        RequestedRangeNotSatisfiable = 416,
        ExpectationFailed = 417,

        // Server Error
        InternalServerError = 500,
        NotImplemented = 501,
        BadGateway = 502,
        ServiceUnavailable = 503,
        GatewayTimeOut = 504,
        HTTPVersionNotSupported = 505
      };
    };
  }
}</code></pre>
<h2 id="the-modules">The modules</h2>
<p>Every module inherit from <code>IModule</code>. This basic interface provide just what is needed to manipulate each module in the same fashion.</p>
<pre><code class="language-cpp">namespace teq
{
  class IModule
  {
  public:
    virtual ~IModule() noexcept {}
    virtual std::string const &amp;name() const = 0;
    virtual std::string const &amp;description() const = 0;
    virtual void init(ACore &amp;core, nlohmann::json const &amp;config) = 0;
  };
}</code></pre>
<p>The <code>init</code> method will be called by the core when it just finished loading the module.
This way, the module will be able to register itself in the right slots onto the core.</p>
<p>For example, a logger <code>init</code> method could look something like this</p>
<pre><code class="language-cpp">void Logger::init(teq::ACore &amp;core, nlohmann::json const &amp;)
{
  core.loggers().add(this, this);
}</code></pre>
<p>We also defined a bit mode specific module type, which is the <code>IMainModule</code>, from which inherit both the Connection module and the Configuration Loader module.</p>
<pre><code class="language-cpp">namespace teq
{
  class IMainModule : public IModule
  {
  public:
    virtual ~IMainModule() noexcept {}
    virtual void enable() = 0;
    virtual void disable() = 0;
  };
}</code></pre>
<p>This might allow us to launch a thread in these modules.
This will be needed by the Connection module, but it can also be used for the Connection Loader module, if we want some hot reload configuration features for example.</p>
<h2 id="the-connection-module">The Connection module</h2>
<p>The connection module has one major functionnality. It has to launch his own thread to manage network I/O with the client independently.</p>
<p>To manage this, the core will give it two <code>http::Message</code> queues.</p>
<p>An <code>http::Message</code> is really simple, it's just a <code>string</code> with an <code>id</code>. This is used by the connection module when it has to send a response, to which request it correspond.</p>
<pre><code class="language-cpp">namespace teq
{
  namespace http
  {
    struct Message
    {
      std::string id;
      std::string content;
    };
  }
}</code></pre>
<p>To achieve that, the <code>IConnection</code> interface provides those methods, in addition to the <code>IMainModule</code> ones</p>
<pre><code class="language-cpp">virtual void setInput(std::queue&lt;http::Message&gt; &amp;queue) = 0;
virtual void setOutput(std::queue&lt;http::Message&gt; &amp;queue) = 0;</code></pre>
<h2 id="the-configuration-loader-module">The Configuration Loader module</h2>
<p>The <code>IConfigLoader</code> allow the core to simply load a configuration file. Your implementation will define the file language (JSON, XML, YAML, ...), but the config itself will be stored as a JSON object (from the <a href="https://github.com/nlohmann/json">nlohmann json Library</a>).</p>
<p>It provide a single method in complement of the <code>IMainModule</code> ones</p>
<pre><code class="language-cpp">namespace teq
{
  class IConfigLoader : public IMainModule
  {
  public:
    virtual ~IConfigLoader() noexcept {}
    virtual void load(std::string const &amp;path, nlohmann::json &amp;config) = 0;
  };
}</code></pre>
<h2 id="the-logger-module">The Logger module</h2>
<p>The <code>ILogger</code> interface only add a <code>log</code> method, which takes a <code>LogType</code> and a <code>string</code> message</p>
<pre><code class="language-cpp">namespace teq
{
  enum class LogType
  {
    Trace,
    Debug,
    Info,
    Warning,
    Error
  };
}</code></pre>
<pre><code class="language-cpp">virtual void log(LogType type, std::string const &amp;message) = 0;</code></pre>
<h2 id="the-handler-module">The Handler module</h2>
<p>The handler module is also quite simple.
The <code>handle</code> method takes the input request, and the output response to fill, and returns a <code>bool</code> to indicate if it effectively handled the request.</p>
<pre><code class="language-cpp">virtual bool handle(http::IRequest &amp;req, http::IResponse &amp;res) = 0;</code></pre>
<p>For example, if you made a simple <code>php</code> file handler, it would look something like this</p>
<pre><code class="language-cpp">bool PhpHandler::handle(http::IRequest &amp;req, http::IResponse &amp;res)
{
  auto path = req.uri().path();

  if (path.size() &gt;= 4 &amp;&amp; path.substr(path.size() - 4, 4) != ".php")
  {
    return false;
  }

  // Handle the request and fill the response
  // ...

  return true;
}</code></pre>
<blockquote>
<p>Please note that this handler is only checking for &quot;.php&quot; extension, which is not the only php valid extension. This is only for code simplicity.</p>
</blockquote>
<h2 id="the-filter-module">The Filter module</h2>
<p>And finally, the <code>IFilter</code> interface. This one is a little bit different, in the fact that it doesn't add any method.
It is only used as a Marker Interface, for polymophism and readability.</p>
<p>Why doesn't it have any method ?
Because filters themselves are functions, and not a module.
With the <code>IModule::init(...)</code> method, you can add callbacks in the differents filter registers.</p>
<p>There are 4 different types of filter</p>
<pre><code class="language-cpp">namespace teq
{
  namespace filter
  {
    enum class Type
    {
      InputData,
      Request,
      Response,
      OutputData
    };
  }
}</code></pre>
<hr />
<p>The <code>InputData</code> filter applies on the input <code>string</code> which comes directly from the Connection module. This is before the string is parsed as a request. It can for example apply some decryption or decompression to the data.</p>
<pre><code class="language-cpp">std::function&lt;void(std::string &amp;)&gt;</code></pre>
<hr />
<p>The <code>Request</code> filter applies, as the name suggest, on the request. This step occurs once the request was parsed, but before it is consumed by a handler.</p>
<pre><code class="language-cpp">std::function&lt;void(http::IRequest &amp;)&gt;</code></pre>
<hr />
<p>The <code>Response</code> filter is really similar to the <code>Request</code> one, it applies on the reponse right after it was filled by a handler.</p>
<pre><code class="language-cpp">std::function&lt;void(http::IResponse &amp;)&gt;</code></pre>
<hr />
<p>The <code>OutputData</code> filter is just as the <code>InputData</code> one, but applies on the output <code>string</code>. This one can apply encryption or compression for example.</p>
<pre><code class="language-cpp">std::function&lt;void(std::string &amp;)&gt;</code></pre>
<h2 id="the-project-uml">The Project UML</h2>
<p><img src="https://github.com/Ludonope/TequilAPI/raw/master/project_uml.png" alt="UML of the API" /></p>
                </section>

            </div>
        </main>

        <footer class="site-footer">
            <div class="top-bar-line"></div>
            <div class="bottom-panel">
                <div class="text-center">
            <span>
                                    A drunk API made by Arthur ARNAUD, Antoine BACHÃ‰, Ludovic PETRENKO and Lucas TRONCY
                                                </span>
                </div><!-- text-center -->
            </div><!-- bottom-panel -->
        </footer>


        <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <script src="http://ludonope.github.io/TequilAPI/js/highlight.pack.js"></script>

        <script>
            hljs.initHighlighting();

            function checkWidth($highlight) {
                if ($(window).width() < 768) {
                    $highlight.addClass('collapse');
                } else {
                    $highlight.removeClass('collapse');
                }
            }

            $(document).ready(function () {
                var $highlights = $('.hljs');
                $highlights.each(function (index) {
                    var $this = $(this).parent();
                    var elementId = 'hljs' + index;
                    $this.attr('id', elementId);
                    $this.before('<a class="visible-xs-inline visible-sm-inline" href="#' + elementId + '" data-toggle="collapse"><i class="fa fa-expand"></i>&nbsp;Toggle source code ...</a>');

                    checkWidth($this);
                    $(window).resize(function () {
                        checkWidth($this);
                    });
                });
            });

            
        </script>

    </body>
</html>
